<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <h1>시험 대비 java 총 정리</h1>

    <br />

    <h2>객체지향의 네 가지 특징</h2>

    <ul>
      <li>추상화</li>
      <li>상속</li>
      <li>다형성</li>
      <li>캡슐화</li>
    </ul>

    <br />

    <p><strong>객체</strong> : 가장 기본적인 단위</p>

    <br />

    <table border="1">
      <thead>
        <tr>
          <th>특성</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>추상화 (Abstraction)</td>
          <td>중요한 부분만 노출하고 불필요한 세부 사항 숨김</td>
        </tr>
        <tr>
          <td>상속 (Inheritance)</td>
          <td>상위 클래스의 속성과 메서드를 하위 클래스가 물려받음</td>
        </tr>
        <tr>
          <td>다형성 (Polymorphism)</td>
          <td>동일한 메서드가 다른 방식으로 동작</td>
        </tr>
        <tr>
          <td>캡슐화 (Encapsulation)</td>
          <td>데이터와 메서드를 하나로 묶어 외부 접근을 제한</td>
        </tr>
      </tbody>
    </table>

    <br />

    <p>
      자세한 내용은
      <a
        href="https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95"
        target="_blank"
        >이 사이트</a
      >
      를 참조
    </p>

    <br />

    <h3>오버로딩과 오버라이딩</h3>
    <table border="1">
      <thead>
        <tr>
          <th>특성</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>오버로딩 (Overloading)</td>
          <td>
            같은 이름의 메서드를 매개변수의 타입이나 개수로 구분하여 여러 개
            정의
          </td>
        </tr>
        <tr>
          <td>오버라이딩 (Overriding)</td>
          <td>상위 클래스의 메서드를 하위 클래스에서 재정의하여 사용</td>
        </tr>
      </tbody>
    </table>

    <br />

    <h2>if, switch-case, for, while</h2>
    <textarea class="javaCode" readonly>
// if 문 예제: 조건이 참일 때 특정 블록을 실행
int number = 10;
if (number > 0) {
    System.out.println("양수입니다."); // number가 0보다 크면 이 메시지가 출력됨
} else {
    System.out.println("음수입니다.");
}

// switch-case 예제: 변수의 값에 따라 다른 블록을 실행
int day = 3;
switch (day) {
    case 1:
        System.out.println("월요일"); // day가 1일 때 실행
        break;
    case 2:
        System.out.println("화요일"); // day가 2일 때 실행
        break;
    case 3:
        System.out.println("수요일"); // day가 3일 때 실행
        break;
    default:
        System.out.println("기타"); // 위의 case에 해당하지 않을 때 실행
        break;
}

// for 문 예제: 정해진 횟수만큼 반복 실행
for (int i = 0; i < 5; i++) {
    System.out.println("반복 횟수: " + i); // i가 0부터 4까지 증가하며 출력됨
}

// while 문 예제: 조건이 참일 동안 반복 실행
int count = 0;
while (count < 5) {
    System.out.println("카운트: " + count); // count가 5 미만일 때 계속 실행
    count++;
}

// do-while 문 예제: 조건이 거짓이어도 최소 한 번은 실행
int count = 0;
do {
    System.out.println("카운트: " + count); // 처음에는 무조건 실행됨
    count++;
} while (count < 5); // count가 5 미만일 동안 반복 실행
      </textarea
    >

    <br />

    <h2>클래스</h2>
    <h3 style="border: none">클래스 생성</h3>
    <textarea class="javaCode" readonly>
ex) Person 클래스

public class Person {
    // 멤버 변수 (필드)
    private String name;
    private int age;

    // 기본 생성자
    public Person() {
        this.name = "Unknown";
        this.age = 0;
    }

    // 매개변수가 있는 생성자
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Getter for name
    public String getName() {
        return name;
    }

    // Setter for name
    public void setName(String name) {
        this.name = name;
    }

    // Getter for age
    public int getAge() {
        return age;
    }

    // Setter for age
    public void setAge(int age) {
        if (age >= 0) {
            this.age = age;
        } else {
            System.out.println("나이는 0 이상이어야 합니다.");
        }
    }

    // Person 객체의 정보를 출력하는 메서드
    public void displayInfo() {
        System.out.println("이름: " + name + ", 나이: " + age);
    }
}
    </textarea>

    <br />
    <br />

    <h3 style="border: none">실행 클래스</h3>
    <textarea class="javaCode" readonly>
// Person 클래스의 객체를 생성하고 사용 예제를 보여주는 실행 클래스
public class Main {
    public static void main(String[] args) {
        // 기본 생성자로 객체 생성
        Person person1 = new Person();
        person1.displayInfo(); // 출력: 이름: Unknown, 나이: 0

        // 매개변수가 있는 생성자로 객체 생성
        Person person2 = new Person("한덕용", 26);
        person2.displayInfo(); // 출력: 이름: 한덕용, 나이: 26

        // 세터를 이용하여 값 변경
        person1.setName("한 살 더 먹은 한덕용");
        person1.setAge(27);
        person1.displayInfo(); // 출력: 이름: 한 살 더 먹은 한덕용, 나이: 27

        // 나이를 잘못 설정하는 경우
        person1.setAge(-5); // 출력: 나이는 0 이상이어야 합니다.

        // person1, person2 객체들은 인스턴스 라고 함.
    }
}
      </textarea
    >

    <br />

    <h3>간단한 용어 표</h3>
    <table>
      <tr>
        <th>용어</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>객체</td>
        <td>객체 지향 프로그램의 대상, 생성된 인스턴스</td>
      </tr>
      <tr>
        <td>클래스</td>
        <td>객체를 프로그래밍하기 위해 코드로 만든 상태</td>
      </tr>
      <tr>
        <td>인스턴스</td>
        <td>클래스가 메모리에 생성된 상태</td>
      </tr>
      <tr>
        <td>인스턴스화</td>
        <td>클래스를 사용해 객체를 생성하는 과정</td>
      </tr>
      <tr>
        <td>멤버 변수</td>
        <td>클래스 안에 선언한 변수</td>
      </tr>
      <tr>
        <td>메서드</td>
        <td>멤버 변수를 이용하여 클래스의 기능을 구현</td>
      </tr>
      <tr>
        <td>참조 변수</td>
        <td>메모리에 생성된 인스턴스를 가리키는 변수</td>
      </tr>
      <tr>
        <td>참조 값</td>
        <td>생성된 인스턴스의 메모리 주소 값</td>
      </tr>
      <tr>
        <td>시그니처</td>
        <td>메서드의 이름과 매개변수로 구성된 선언부</td>
      </tr>
      <tr>
        <td>생성자</td>
        <td>객체 생성 시 호출되는 메서드로, 초기화 역할을 수행</td>
      </tr>
      <tr>
        <td>오버로딩</td>
        <td>
          동일한 이름의 메서드를 매개변수의 종류나 개수에 따라 여러 개 정의
        </td>
      </tr>
      <tr>
        <td>오버라이딩</td>
        <td>상위 클래스의 메서드를 하위 클래스에서 재정의하여 사용</td>
      </tr>
      <tr>
        <td>패키지</td>
        <td>관련된 클래스들을 그룹화하여 관리하는 디렉토리 구조</td>
      </tr>
      <tr>
        <td>추상 클래스</td>
        <td>추상 메서드를 포함할 수 있는 클래스, 직접 인스턴스화할 수 없음</td>
      </tr>
      <tr>
        <td>인터페이스</td>
        <td>구현할 메서드의 선언만 포함하며, 클래스가 이를 구현하도록 강제</td>
      </tr>
    </table>

    <br />

    <h3>생성자</h3>
    <ul>
      <li>
        클래스의 객체가 생성될 때 호출되는 메서드로, 객체의 초기화를 담당함
      </li>
      <li>생성자의 이름은 클래스의 이름과 동일하며, 반환 타입이 없음</li>
    </ul>

    <br />
    <textarea class="javaCode" readonly>
// Person 클래스 예제
class Person {
    private String name;
    private int age;

    // 디폴트 생성자: 매개변수가 없는 생성자
    // 생성자를 따로 정의하지 않으면 컴파일러가 자동으로 생성
    public Person() {
        this.name = "Unknown";
        this.age = 0;
    }

    // 오버로딩된 생성자: 매개변수가 있는 생성자
    // 동일한 이름의 생성자지만 매개변수의 종류나 개수가 다름
    public Person(String name, int age) {
        this.name = name;
        setAge(age);
    }

    // 이름 설정 메서드
    public void setName(String name) {
        this.name = name;
    }

    // 나이 설정 메서드
    public void setAge(int age) {
        if (age >= 0) {
            this.age = age;
        } else {
            System.out.println("나이는 0 이상이어야 합니다.");
        }
    }

    // 객체의 정보를 출력하는 메서드
    public void displayInfo() {
        System.out.println("이름: " + name + ", 나이: " + age);
    }
}
    </textarea>

    <br />

    <ul>
      <li>
        <strong>디폴트 생성자</strong>: <code>Person()</code>과 같이 매개변수가
        없는 생성자이며, 객체 생성 시 기본값을 설정함.
      </li>
      <li>
        <strong>오버로딩</strong>: 동일한 이름의 생성자가 여러 개 정의되어,
        매개변수에 따라 다른 생성자가 호출됨.
      </li>
      <li>
        <strong>오버로딩된 생성자</strong>:
        <code>Person(String name, int age)</code>와 같이 매개변수가 있는
        생성자로, 전달받은 값을 이용해 객체를 초기화함.
      </li>
    </ul>

    <br />

    <h3>접근 제어자</h3>
    <table>
      <thead>
        <tr>
          <th>접근 제어자</th>
          <th>설명</th>
          <th>접근 가능 범위</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>public</td>
          <td>모든 클래스에서 접근 가능</td>
          <td>전체(프로젝트 내 어디서든)</td>
        </tr>
        <tr>
          <td>protected</td>
          <td>같은 패키지 또는 상속받은 클래스에서 접근 가능</td>
          <td>같은 패키지 + 하위 클래스</td>
        </tr>
        <tr>
          <td>default</td>
          <td>접근 제어자를 명시하지 않은 경우 사용</td>
          <td>같은 패키지 내에서만 접근 가능</td>
        </tr>
        <tr>
          <td>private</td>
          <td>해당 클래스 내부에서만 접근 가능</td>
          <td>같은 클래스 내에서만</td>
        </tr>
      </tbody>
    </table>

    <br />

    <h3>this와 super</h3>
    <table>
      <tr>
        <th>용어</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>this 예약어</td>
        <td>
          현재 객체를 가리키는 참조 변수로, 같은 클래스 내에서 멤버 변수와
          메서드를 호출할 때 사용
        </td>
      </tr>
      <tr>
        <td>super 예약어</td>
        <td>
          상위 클래스의 멤버를 가리키는 참조 변수로, 상위 클래스의 생성자나
          메서드, 변수를 호출할 때 사용
        </td>
      </tr>
      <tr>
        <td>this() 메서드</td>
        <td>현재 클래스의 다른 생성자를 호출할 때 사용</td>
      </tr>
      <tr>
        <td>super() 메서드</td>
        <td>상위 클래스의 생성자를 호출할 때 사용</td>
      </tr>
    </table>

    <br />

    <textarea class="javaCode" readonly>
// this 예제

public class Person {
    private String name;

    public Person(String name) {
        this.name = name; // 여기서 this.name은 멤버 변수, name은 생성자의 매개변수
    }
}


// this() 예제

public class Person {
    private String name;
    private int age;

    public Person() {
        this("Unknown", 0); // this()를 사용하여 다른 생성자 호출
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}


// super 예제

class Animal {
    String name = "동물";

    void sound() {
        System.out.println("동물의 소리");
    }
}

class Dog extends Animal {
    String name = "개";

    void sound() {
        super.sound(); // 부모 클래스의 sound() 호출
        System.out.println("멍멍");
    }

    void displayName() {
        System.out.println(super.name); // 부모 클래스의 name 필드 참조
        System.out.println(this.name);  // 현재 클래스의 name 필드 참조
    }
}


// super() 예제

class Animal {
    Animal() {
        System.out.println("Animal 생성자");
    }
}

class Dog extends Animal {
    Dog() {
        super(); // 부모 클래스의 기본 생성자 호출
        System.out.println("Dog 생성자");
    }
}
    </textarea>

    <br />

    <h3>변수의 유효 범위</h3>
    <table>
      <tr>
        <th>변수 종류</th>
        <th>설명</th>
        <th>유효 범위</th>
      </tr>
      <tr>
        <td>지역 변수</td>
        <td>메서드나 블록 내부에서 선언된 변수</td>
        <td>변수가 선언된 메서드나 블록 내부에서만 사용 가능</td>
      </tr>
      <tr>
        <td>멤버 변수</td>
        <td>클래스의 속성으로, 객체가 생성될 때마다 할당됨</td>
        <td>클래스 내 모든 메서드에서 사용 가능, 객체가 존재하는 동안 유효</td>
      </tr>
      <tr>
        <td>static 변수</td>
        <td>클래스에 속하며, 모든 인스턴스가 공유하는 변수</td>
        <td>
          프로그램이 종료될 때까지 클래스 내에서 유효, 객체 없이도 사용 가능
        </td>
      </tr>
    </table>

    <br />

    <h2>배열</h2>
    <textarea class="javaCode" readonly>
// 1. 배열 선언
int[] arr1;

// 2. 배열 선언과 동시에 초기화
int[] arr2 = {1, 2, 3};

// 3. new 키워드를 사용한 배열 초기화
int[] arr3 = new int[3];
arr3[0] = 1;
arr3[1] = 2;
arr3[2] = 3;

// 4. 반복문을 이용한 배열 초기화
int[] arr4 = new int[3];
for (int i = 0; i < arr4.length; i++) {
  arr4[i] = i + 1;
}

// 5. 다차원 배열 초기화
String[][] multiArr1;

// 6. 다차원 배열 선언과 동시에 초기화
String[][] multiArr2 = {
    {"일", "이", "삼"},
    {"사", "오", "육"},
    {"칠", "팔", "구"}
};

// 7. new 키워드를 사용한 다차원 배열 초기화
String[][] multiArr3 = new String[3][3];
multiArr3[0][0] = "일";
multiArr3[0][1] = "이";
multiArr3[0][2] = "삼";
multiArr3[1][0] = "사";

      .
      .
      .

multiArr3[2][2] = "구";

// 8, 반복문을 이용한 다차원 배열 초기화
int[][] multiArr4 = new int[3][3];
for (int i = 0; i < multiArr4.length; i++) {
  for (int j = 0; j < multiArr4[i].length; j++) {
    multiArr4[i][j] = i + j;
  }
}
      </textarea
    >

    <br />

    <h3>System.arraycopy(src, srcPos, dest, destPos, length) 메서드</h3>
    <table>
      <tr>
        <th>매개변수</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>src</td>
        <td>복사할 배열 이름</td>
      </tr>
      <tr>
        <td>srcPos</td>
        <td>복사할 배열의 첫 번째 위치</td>
      </tr>
      <tr>
        <td>dest</td>
        <td>복사해서 붙여 넣을 대상 배열 이름</td>
      </tr>
      <tr>
        <td>destPos</td>
        <td>복사해서 대상 배열에 붙여 넣기를 시작할 첫 번째 위치</td>
      </tr>
      <tr>
        <td>length</td>
        <td>src에서 dest로 자료를 복사할 요소 개수</td>
      </tr>
    </table>

    <br />

    <h3>얕은 복사, 깊은 복사</h3>
    <ul>
      <li>
        <strong>얕은 복사 (Shallow Copy)</strong>
        <p>
          배열의 참조 값만 복사하여, 원본 배열과 복사된 배열이 같은 메모리
          공간을 공유함. 하나의 배열에서 값을 변경하면 다른 배열에도 영향을
          미침.
        </p>
      </li>
      <li>
        <strong>깊은 복사 (Deep Copy)</strong>
        <p>
          배열의 각 요소를 새롭게 복사하여, 복사된 배열과 원본 배열이 서로 다른
          메모리 공간을 가짐. 따라서 값 변경 시 서로에게 영향을 미치지 않음.
        </p>
      </li>
    </ul>
    <textarea class="javaCode" readonly>
      // 얕은 복사 (Shallow Copy)
      int[] originalArray = {1, 2, 3, 4, 5};
      int[] shallowCopy = originalArray; // 얕은 복사
      shallowCopy[0] = 10;
      System.out.println(originalArray[0]); // 출력: 10 (원본 배열도 값이 변경됨)
      
      // 깊은 복사 (Deep Copy)
      int[] deepCopy = new int[originalArray.length];
      for (int i = 0; i < originalArray.length; i++) {
          deepCopy[i] = originalArray[i]; // 깊은 복사
      }
      deepCopy[0] = 20;
      System.out.println(originalArray[0]); // 출력: 10 (원본 배열은 영향을 받지 않음)
      </textarea
    >

    <br />

    <h3>ArrayList</h3>
    <table>
      <thead>
        <tr>
          <th>메서드</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>add(E e)</td>
          <td>리스트의 마지막에 요소를 추가</td>
        </tr>
        <tr>
          <td>add(int index, E element)</td>
          <td>지정된 위치에 요소를 추가</td>
        </tr>
        <tr>
          <td>get(int index)</td>
          <td>지정된 위치의 요소를 반환</td>
        </tr>
        <tr>
          <td>set(int index, E element)</td>
          <td>지정된 위치의 요소를 주어진 값으로 수정</td>
        </tr>
        <tr>
          <td>remove(int index)</td>
          <td>지정된 위치의 요소를 제거</td>
        </tr>
        <tr>
          <td>remove(Object o)</td>
          <td>리스트에서 해당 객체를 제거 (첫 번째로 일치하는 요소)</td>
        </tr>
        <tr>
          <td>clear()</td>
          <td>리스트의 모든 요소를 제거</td>
        </tr>
        <tr>
          <td>size()</td>
          <td>리스트의 요소 개수를 반환</td>
        </tr>
        <tr>
          <td>isEmpty()</td>
          <td>리스트가 비어 있는지 여부를 반환</td>
        </tr>
        <tr>
          <td>contains(Object o)</td>
          <td>리스트에 해당 객체가 포함되어 있는지 여부를 반환</td>
        </tr>
        <tr>
          <td>indexOf(Object o)</td>
          <td>리스트에서 해당 객체가 처음으로 나타나는 위치의 인덱스를 반환</td>
        </tr>
        <tr>
          <td>lastIndexOf(Object o)</td>
          <td>
            리스트에서 해당 객체가 마지막으로 나타나는 위치의 인덱스를 반환
          </td>
        </tr>
        <tr>
          <td>toArray()</td>
          <td>리스트의 모든 요소를 배열로 반환</td>
        </tr>
      </tbody>
    </table>

    <br />

    <h2>상속, 다형성 예제</h2>
    <textarea class="javaCode" readonly>
// 상속 예제
// 부모 클래스 Animal
class Animal {
    String name;

    // 부모 클래스의 생성자
    public Animal(String name) {
        this.name = name;
    }

    // 부모 클래스의 메서드
    public void sound() {
        System.out.println("동물이 소리를 냅니다.");
    }
}

// 자식 클래스 Dog (Animal을 상속)
class Dog extends Animal {
    
    // 자식 클래스의 생성자
    public Dog(String name) {
        super(name); // 부모 클래스의 생성자 호출
    }

    // 메서드 오버라이딩: 부모 클래스의 메서드를 재정의
    @Override
    public void sound() {
        System.out.println(name + "가(이) 멍멍 소리를 냅니다.");
    }
}

// 다형성 예제
public class Main {
    public static void main(String[] args) {
        // 부모 클래스 타입으로 자식 클래스 객체를 참조 (다형성)
        Animal myDog = new Dog("바다");
        myDog.sound(); // 출력: 바다가 멍멍 소리를 냅니다.
        
        // 자식 클래스 타입으로 객체를 참조
        Dog anotherDog = new Dog("해피");
        anotherDog.sound(); // 출력: 해피가 멍멍 소리를 냅니다.
    }
}
    </textarea>

    <br />

    <h3>상속에서 super 메서드 사용 예제</h3>

    <textarea class="javaCode" readonly>
// 상속에서 super 메서드 사용 예제

// 부모 클래스 Animal
class Animal {
    String name;

    // 부모 클래스의 생성자
    public Animal(String name) {
        this.name = name;
    }

    // 부모 클래스의 메서드
    public void sound() {
        System.out.println("동물이 소리를 냅니다.");
    }

    // 부모 클래스의 메서드
    public void eat() {
        System.out.println(name + "가(이) 먹이를 먹습니다.");
    }
}

// 자식 클래스 Dog (Animal을 상속)
class Dog extends Animal {

    // 자식 클래스의 생성자
    public Dog(String name) {
        super(name); // 부모 클래스의 생성자 호출
    }

    // 메서드 오버라이딩: 부모 클래스의 메서드를 재정의
    @Override
    public void sound() {
        super.sound(); // 부모 클래스의 sound() 메서드 호출
        System.out.println(name + "가(이) 멍멍 소리를 냅니다.");
    }

    // 자식 클래스의 메서드
    public void play() {
        System.out.println(name + "가(이) 공놀이를 합니다.");
    }
}

// 메인 클래스
public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog("바둑이");

        // 부모 클래스의 메서드 호출
        myDog.eat(); // 출력: 바둑이가 먹이를 먹습니다.

        // 오버라이딩된 메서드와 super 사용한 메서드 호출
        myDog.sound(); // 출력: 동물이 소리를 냅니다. / 바둑이가 멍멍 소리를 냅니다.

        // 자식 클래스의 메서드 호출
        myDog.play(); // 출력: 바둑이가 공놀이를 합니다.
    }
}
    </textarea>

    <br />

    <h3>다운캐스팅과 instanceof</h3>

    <ul>
      <li>
        <strong>다운캐스팅 (Downcasting):</strong>
        <p>부모 클래스 타입의 객체를 자식 클래스 타입으로 변환하는 것.</p>
        <p>
          다운캐스팅을 할 때는 반드시 해당 객체가 실제로 그 자식 클래스 타입인지
          확인해야 함.
        </p>
      </li>

      <li>
        <strong>instanceof:</strong>
        <p>객체가 특정 클래스의 인스턴스인지 확인하는 키워드.</p>
        <p>다운캐스팅 전에 객체의 타입을 확인할 때 사용됨.</p>
      </li>
    </ul>

    <textarea class="javaCode" readonly>
// 다운캐스팅과 instanceof 예제
Animal animal = new Dog("바둑이");

if (animal instanceof Dog) {
    Dog dog = (Dog) animal; // 다운캐스팅
    dog.play(); // Dog 클래스의 메서드를 사용
} else {
    System.out.println("이 객체는 Dog 타입이 아닙니다.");
}
    </textarea>

    <br />

    <h2>추상 클래스</h2>

    <br />

    <h2>메모리 공간</h2>
    <table>
      <thead>
        <tr>
          <th>메모리 공간</th>
          <th>설명</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>스택 (Stack)</td>
          <td>
            메서드 호출 시 생성되는 지역 변수와 매개변수가 저장됨. 메서드가
            종료되면 자동으로 제거됨
          </td>
        </tr>
        <tr>
          <td>힙 (Heap)</td>
          <td>
            new 키워드를 사용해 생성된 객체와 배열이 저장됨. Garbage Collector가
            관리
          </td>
        </tr>
        <tr>
          <td>메서드 영역 (Method Area)</td>
          <td>
            클래스 정보, 메서드, static 변수 등이 저장됨. 프로그램 시작 시
            로드되고 종료 시까지 유지됨
          </td>
        </tr>
        <tr>
          <td>PC 레지스터 (Program Counter)</td>
          <td>
            현재 실행 중인 명령어의 위치를 저장함. 각 스레드마다 개별적으로 존재
          </td>
        </tr>
        <tr>
          <td>네이티브 메서드 스택 (Native Method Stack)</td>
          <td>
            자바 외의 언어로 작성된 네이티브 메서드가 호출될 때 사용되는 메모리
            공간
          </td>
        </tr>
      </tbody>
    </table>

    <script src="script.js"></script>
  </body>
</html>
