<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <h1>시험 대비 jsp 총 정리</h1>

    <br />

    <h2>정적 웹 페이지</h2>
    <p>
      웹 서버에 저장되어 있는 파일을 그대로 웹 브라우저에 전송해 출력하는 가장
      기본적인 웹 페이지
    </p>

    <br />

    <h2>동적 웹 페이지</h2>
    <p>
      서버가 클라이언트의 요청을 해석하여 가장 적절한 웹 페이지를 그때그때
      생성해 보내주는 기술
    </p>

    <br />

    <h2>애플릿</h2>
    <p>클라이언트 측에서 실행되는 Java 프로그램</p>

    <br />

    <h2>서블릿</h2>
    <p>서버 측에서 실행되는 Java 프로그램</p>

    <br />

    <h2>JSP 구성 요소</h2>
    <p>JSP는 지시어, 선언부, 표현식, 스크립틀릿으로 구성됨.</p>

    <br />

    <h3>지시어</h3>
    <ul>
      <li><strong>page</strong>: JSP 페이지에 대한 정보를 설정하는 지시어</li>
      <li><strong>include</strong>: 반복되는 페이지 포함</li>
      <li><strong>taglib</strong>: JSP 라이브러리 사용을 위한 지시어</li>
    </ul>

    <br />

    <h3>스크립트 요소</h3>
    <ul>
      <li>
        <strong>선언부</strong>: <code>&lt;%!&gt;</code> 사용할 변수나 메서드
        등을 선언
      </li>
      <li>
        <strong>스크립틀릿</strong>: <code>&lt;%&gt;</code> 실행할 자바 코드
      </li>
      <li>
        <strong>표현식</strong>: <code>&lt;%= %&gt;</code> 실행 결과 값이 하나만
        남는 문장
      </li>
    </ul>

    <br />

    <h2>URL과 URI</h2>
    <ul>
      <li><strong>URL</strong>: 도메인을 포함한 페이지 경로</li>
      <li><strong>URI</strong>: 도메인을 제외한 페이지 경로</li>
    </ul>

    <br />

    <h2>내장 객체</h2>
    <table border="1">
      <caption>
        내장 객체의 종류
      </caption>
      <tr>
        <th>내장 객체</th>
        <th>타입</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>request</td>
        <td>jakarta.servlet.http.HttpServletRequest</td>
        <td>클라이언트의 요청 정보를 저장합니다.</td>
      </tr>
      <tr>
        <td>response</td>
        <td>jakarta.servlet.http.HttpServletResponse</td>
        <td>클라이언트의 요청에 대한 응답 정보를 저장합니다.</td>
      </tr>
      <tr>
        <td>out</td>
        <td>jakarta.servlet.jsp.JspWriter</td>
        <td>JSP 페이지에 출력할 내용을 담는 출력 스트림입니다.</td>
      </tr>
      <tr>
        <td>session</td>
        <td>jakarta.servlet.http.HttpSession</td>
        <td>웹 브라우저 정보를 유지하기 위한 세션 정보를 저장합니다.</td>
      </tr>
      <tr>
        <td>application</td>
        <td>jakarta.servlet.ServletContext</td>
        <td>웹 애플리케이션 관련 컨텍스트 정보를 저장합니다.</td>
      </tr>
      <tr>
        <td>pageContext</td>
        <td>jakarta.servlet.jsp.PageContext</td>
        <td>JSP 페이지에 대한 정보를 저장합니다.</td>
      </tr>
      <tr>
        <td>page</td>
        <td>java.lang.Object</td>
        <td>JSP 페이지를 구현한 자바 클래스의 인스턴스입니다.</td>
      </tr>
      <tr>
        <td>config</td>
        <td>jakarta.servlet.ServletConfig</td>
        <td>JSP 페이지에 대한 설정 정보를 저장합니다.</td>
      </tr>
      <tr>
        <td>exception</td>
        <td>java.lang.Throwable</td>
        <td>예외가 발생한 경우에 사용합니다.</td>
      </tr>
    </table>

    <br />

    <h2>내장 객체의 영역</h2>
    <ul>
      <li>
        <strong>page</strong>: 동일한 페이지에서만 공유, 페이지를 벗어나면 소멸
      </li>
      <li>
        <strong>request 영역</strong>: 하나의 요청에 의해 호출된 페이지와
        포워드된 페이지까지 공유, 새로운 페이지를 요청(페이지 이동)하면 소멸
      </li>
      <li>
        <strong>session</strong>: 클라이언트가 처음 접속한 후 웹 브라우저를 닫을
        때까지 공유, 포워드나 페이지 이동 시에도 소멸하지 않음
      </li>
      <li>
        <strong>application</strong>: 한 번 저장되면 웹 애플리케이션이 종료될
        때까지 유지
      </li>
      <li>크기 : application > session > request > page</li>
    </ul>

    <br />

    <h3>영역의 주요 스코프</h3>
    <table border="1">
      <tr>
        <th>메서드</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>setAttribute</td>
        <td>속성을 저장합니다. (이름과 값을 설정)</td>
      </tr>
      <tr>
        <td>getAttribute</td>
        <td>저장된 속성 값을 가져옵니다.</td>
      </tr>
      <tr>
        <td>removeAttribute</td>
        <td>저장된 속성을 제거합니다.</td>
      </tr>
    </table>

    <br />

    <h2>자바빈즈 규약</h2>
    <ul>
      <li>자바 빈즈는 기본(default) 패키지 이외의 패키지에 속해야 함</li>
      <li>프로퍼티(멤버 변수)의 접근 지정자는 private로 선언</li>
      <li>기본 생성자가 반드시 있어야 함</li>
      <li>프로퍼티에 접근할 수 있는 getter / setter 필요</li>
      <li>public getter/setter 필요</li>
    </ul>

    <br />

    <h2>데이터 객체</h2>
    <ul>
      <li>
        데이터 전송 객체(DTO, Data Transfer Object) <- -> DAO (Data Access
        Object)
        <ul>
          <li>다른 페이지, 다른 시스템과 데이터를 주고 받기 위한 용도</li>
          <li>
            전송을 위한 필드의 생성, 프로세스 <- -> DAO 객체의 필드와 1:1 매핑이
            되지 않을 수 있다.
          </li>
        </ul>
      </li>
      <li>
        데이터 접근 객체(DAO, Data Access Object)
        <ul>
          <li>데이터베이스 처리용</li>
        </ul>
      </li>
      <li>
        VO(Value Object) 객체
        <ul>
          <li>데이터 저장용으로만 사용</li>
          <li>프로퍼티(멤버필드) <- -> 데이터 베이스 간 1:1 매핑으로 작성</li>
        </ul>
      </li>
    </ul>

    <br />

    <h2>쿠키 정의 및 특징</h2>
    <ul>
      <li>
        클라이언트의 상태 정보를 유지하기 위한 기술 (HTTP의 비연결 지향형 특성
        때문에 필요)
      </li>
      <li>사용 정보를 클라이언트 PC에 저장 (주로 key/value 형태)</li>
      <ul>
        <li>최대 3000개 생성 가능</li>
        <li>하나의 쿠키 크기 최대 4096 바이트</li>
        <li>도메인당 최대 50개 생성 가능</li>
      </ul>
      <li>대략 1.2MB까지 저장 가능</li>
    </ul>

    <br />

    <h2>쿠키 기본 동작</h2>
    <ol>
      <li>클라이언트가 서버에 첫 요청 시 서버는 쿠키를 생성해 전송</li>
      <li>클라이언트는 로컬에 쿠키를 저장</li>
      <li>이후 클라이언트는 요청 시 쿠키를 서버에 전송하여 서버가 읽고 사용</li>
    </ol>

    <br />

    <h3>쿠키 속성 메서드</h3>
    <table border="1">
      <tr>
        <th>속성</th>
        <th>설정 메서드</th>
        <th>조회 메서드</th>
      </tr>
      <tr>
        <td>이름</td>
        <td>없음</td>
        <td>String getName()</td>
      </tr>
      <tr>
        <td>값</td>
        <td>void setValue(String value)</td>
        <td>String getValue()</td>
      </tr>
      <tr>
        <td>경로</td>
        <td>void setPath(String path)</td>
        <td>String getPath()</td>
      </tr>
      <tr>
        <td>유지시간</td>
        <td>void setMaxAge(int second)</td>
        <td>int getMaxAge()</td>
      </tr>
      <tr>
        <td>도메인</td>
        <td>void setDomain(String domain)</td>
        <td>String getDomain()</td>
      </tr>
    </table>

    <br />

    <h2>쿠키 사용 주의사항</h2>
    <ul>
      <li>set 메서드로 속성을 설정하고, get 메서드로 속성 값을 조회</li>
      <li>쿠키 이름은 생성자를 통해서만 설정 가능하고, 이후 변경 불가</li>
      <li>response.addCookie() 메서드로 쿠키를 저장</li>
      <li>
        쿠키 생성 후 즉시 사용은 불가하며, 페이지 이동 또는 새로고침 이후에 사용
        가능
      </li>
    </ul>

    <br />

    <h2>데이터베이스 연결 ( ---MariaDB 기준--- )</h2>
    <h3 style="border: none">JDBC 프로그래밍 순서</h3>
    <ol>
      <li>JDBC 드라이버 로드 -> DB마다 다르다.</li>
      <li>데이터 베이스 연결 -> DriverManager <= 연결 정보(url, id, pwd)</li>
      <li>쿼리문 작성</li>
      <li>PreparedStatement 문 작성 -> statement 구문</li>
      <li>
        쿼리 실행 -> createStatement, prepareCreate 둘의 적용 방법이 다르다.
      </li>
      <li>결과 처리 -> 조회 ResultSet, 등록 / 수정 / 삭제 : int 값으로 처리</li>
      <li>연결 해제 -> 작은 범위 -> 큰 범위 순으로 해제</li>
    </ol>

    <br />

    <h3>쿼리문 정리</h3>
    <ul>
      <li>정적 쿼리 : Statement</li>
      <li>동적 쿼리 : PreparedStatement (이걸 사용 권장)</li>
      <li>
        메서드
        <ul>
          <li>
            executeQuery()
            <ul>
              <li>SELECT 할 때</li>
              <li>리턴 타입 : ResultSet</li>
            </ul>
          </li>
          <li>
            executeUpdate()
            <ul>
              <li>INSERT / UPDATE / DELETE 할 때</li>
              <li>리턴 타입 : Int</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
    <p>웹은 기본적으로 비 연결 지향</p>

    <br />

    <h2>Connection Pool 방법</h2>
    <p>
      Connection 객체를 미리 생성해 pool에 넣어놓고 요청이 있을 때 이미 생성된
      Connection객체를 가져다 사용하는 기법
    </p>

    <br />

    <h3>// DBConnPool.java</h3>
    <textarea class="javaCode" readonly>
import java.sql.Connection; // DB 연결을 위한 Connection 객체 임포트
import java.sql.PreparedStatement; // SQL 쿼리 실행을 위한 PreparedStatement 객체 임포트
import java.sql.ResultSet; // 쿼리 결과를 저장하기 위한 ResultSet 객체 임포트
import java.sql.Statement; // 일반 SQL 쿼리를 실행하기 위한 Statement 객체 임포트
import javax.naming.Context; // JNDI Initial Context 사용을 위한 Context 객체 임포트
import javax.naming.InitialContext; // 초기 컨텍스트 설정을 위한 InitialContext 객체 임포트
import javax.sql.DataSource; // 데이터 소스 사용을 위한 DataSource 객체 임포트

public class DBConnPool {
    public Connection con; // 데이터베이스 연결 객체
    public Statement stmt; // 일반 SQL 쿼리 실행 객체
    public PreparedStatement pstm; // 준비된 SQL 쿼리 실행 객체
    public ResultSet rs; // SQL 쿼리 결과 객체

    // 연결 DBCP (DataBase Connection Pool) 설정
    public DBConnPool() {
        try {
            Context initCtx = new InitialContext(); // 초기 컨텍스트 생성
            Context ctx = (Context) initCtx.lookup("java:comp/env"); // 환경 설정에서 컨텍스트 조회
            DataSource ds = (DataSource) ctx.lookup("jdbc_fullstack7"); // 데이터 소스 조회
            con = ds.getConnection(); // 데이터베이스 연결 생성
            System.out.println("===================================================");
            System.out.println("DB커넥션풀접속 성공"); // 연결 성공 메시지 출력
            System.out.println("con1 String : " + con); // 연결 객체 정보 출력
            System.out.println("===================================================");
        } catch (Exception e) {
            e.printStackTrace(); // 예외 스택 트레이스 출력
            System.out.println("===================================================");
            System.out.println("DB커넥션풀접속연결실패"); // 연결 실패 메시지 출력
            System.out.println("에러메세지 " + e.getMessage()); // 예외 메시지 출력
            System.out.println("===================================================");
        }
    }

    // 연결 해제(리소스 자원 반납)
    public void close() {
        try {
            if (rs != null) rs.close(); // ResultSet 자원 해제
            if (pstm != null) pstm.close(); // PreparedStatement 자원 해제
            if (stmt != null) stmt.close(); // Statement 자원 해제
            if (con != null) con.close(); // Connection 자원 해제
            System.out.println("===================================================");
            System.out.println("JDBC자원해제"); // 자원 해제 완료 메시지 출력
            System.out.println("===================================================");
        } catch (Exception e) {
            e.printStackTrace(); // 예외 스택 트레이스 출력
            System.out.println("===================================================");
            System.out.println("에러메세지 " + e.getMessage()); // 예외 메시지 출력
            System.out.println("===================================================");
        }
    }
}
    </textarea>

    <br />

    <ul>
      <li>
        <strong>auth="Container"</strong>: 리소스를 컨테이너에서 관리하도록 설정
      </li>
      <li>
        <strong>driverClassName="org.mariadb.jdbc.Driver"</strong>: MariaDB JDBC
        드라이버 클래스 지정
      </li>
      <li>
        <strong>maxIdle="10"</strong>: 풀에서 유지할 수 있는 최소 유휴 연결 수
      </li>
      <li>
        <strong>maxTotal="20"</strong>: 동시에 사용할 수 있는 최대 연결 수
      </li>
      <li>
        <strong>maxWaitMillis="10000"</strong>: 새로운 요청이 들어왔을 때 최대
        대기 시간(밀리초 단위)
      </li>
      <li><strong>name="jdbc_fullstack7"</strong>: 데이터 소스의 이름 설정</li>
      <li>
        <strong>password="1234"</strong>: 데이터베이스 접속 시 사용할 계정의
        비밀번호
      </li>
      <li>
        <strong>type="javax.sql.DataSource"</strong>: 사용되는 데이터 소스의
        타입 지정
      </li>
      <li>
        <strong>url="jdbc:mariadb://localhost:3306/fullstack7"</strong>: MariaDB
        데이터베이스에 연결하기 위한 URL
      </li>
      <li>
        <strong>username="root"</strong>: 데이터베이스 접속 시 사용할 계정의
        사용자명
      </li>
    </ul>

    <br />

    <h3>server.xml</h3>
    <textarea class="javaCode" readonly oninput="autoResize(this)">
// GlobalNamingResources를 수정
<GlobalNamingResources>
  <Resource 
      auth="Container"
      driverClassName="org.mariadb.jdbc.Driver"
      maxIdle="10"
      maxTotal="20"
      maxWaitMillis="10000"
      name="jdbc_fullstack7"
      password="1234"
      type="javax.sql.DataSource"
      url="jdbc:mariadb://localhost:3306/fullstack7"
      username="root" 
  />
</GlobalNamingResources>
    </textarea>

    <br />

    <ul>
      <li>
        <strong>auth="Container"</strong>: 리소스를 컨테이너에서 관리하도록 설정
      </li>
      <li>
        <strong>driverClassName="org.mariadb.jdbc.Driver"</strong>: MariaDB JDBC
        드라이버 클래스 지정
      </li>
      <li>
        <strong>maxIdle="10"</strong>: 풀에서 유지할 수 있는 최소 유휴 연결 수
      </li>
      <li>
        <strong>maxTotal="20"</strong>: 동시에 사용할 수 있는 최대 연결 수
      </li>
      <li>
        <strong>maxWaitMillis="10000"</strong>: 새로운 요청이 들어왔을 때 최대
        대기 시간(밀리초 단위)
      </li>
      <li><strong>name="jdbc_fullstack7"</strong>: 데이터 소스의 이름 설정</li>
      <li>
        <strong>password="1234"</strong>: 데이터베이스 접속 시 사용할 계정의
        비밀번호
      </li>
      <li>
        <strong>type="javax.sql.DataSource"</strong>: 사용되는 데이터 소스의
        타입 지정
      </li>
      <li>
        <strong>url="jdbc:mariadb://localhost:3306/fullstack7"</strong>: MariaDB
        데이터베이스에 연결하기 위한 URL
      </li>
      <li>
        <strong>username="root"</strong>: 데이터베이스 접속 시 사용할 계정의
        사용자명
      </li>
    </ul>

    <br />

    <h3>context.xml</h3>
    <textarea class="javaCode" readonly oninput="autoResize(this)">
// 그대로 추가
// context.xml
<ResourceLink name="jdbc_fullstack7"
global="jdbc_fullstack7"
type="javax.sql.DataSource"/>
    </textarea>

    <br />

    <h2>세션</h2>
    <ul>
      <li>
        클라이언트 (웹 브라우저)가 서버에 접속한 후, 브라우저를 종료하기
        전까지의 단위를 세션
      </li>
      <li>접속하는 동안에 시간 + 작업 내역 등을 유지하기 위함이 목적</li>
    </ul>

    <br />

    <h3>web.xml에서 세션 유지 시간 설정 방법</h3>
    <textarea class="javaCode" readonly oninput="autoResize(this)">
// web.xml
<session-config>
  <session-timeout>20</session-timeout>
</session-config>
    </textarea>

    <br />

    <h3>jsp파일에서 session 내장 객체로 시간 설정</h3>
    <textarea class="javaCode" readonly oninput="autoResize(this)">
// web.xml과 달리 시간 단위는 초
<%
session.setMaxInactivateInterval(1800);
%>
    </textarea>

    <br />

    <table>
      <tr>
        <th>구분</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>void setMaxInactivateInterval(int 초)</td>
        <td>
          세션 유지 시간 -> 프로그램 초 단위<br />
          웹 서비스 설정 -> 분 단위, web.xml 에 설정
        </td>
      </tr>
      <tr>
        <td>int getMaxInactivateInterval()</td>
        <td>세션 유지 시간을 초 단위로 출력</td>
      </tr>
      <tr>
        <td>long getCreateTime()</td>
        <td>세션 최초 요청 시간</td>
      </tr>
      <tr>
        <td>long getLastAccessedTime()</td>
        <td>제일 마지막 요청한 시간</td>
      </tr>
      <tr>
        <td>String getId()</td>
        <td>웹 브라우저가 생성한 세션 ID</td>
      </tr>
      <tr>
        <td>Object getAttribute(String name)</td>
        <td>세션에 저장된 특정 속성 값을 반환</td>
      </tr>
      <tr>
        <td>void setAttribute(String name, Object value)</td>
        <td>세션에 속성 값을 저장 (이름-값 형태로 저장)</td>
      </tr>
      <tr>
        <td>void removeAttribute(String name)</td>
        <td>세션에서 특정 속성 값을 제거</td>
      </tr>
      <tr>
        <td>void invalidate()</td>
        <td>현재 세션을 무효화하여 세션을 종료(로그아웃 처리)</td>
      </tr>
      <tr>
        <td>boolean isNew()</td>
        <td>세션이 처음 생성된 것인지 여부를 반환</td>
      </tr>
    </table>

    <br />

    <table>
      <tr>
        <th></th>
        <th>쿠키</th>
        <th>세션</th>
      </tr>
      <tr>
        <td>저장 위치 / 형식</td>
        <td>클라이언트 PC에 text로 저장</td>
        <td>웹 서버에 Object 타입으로 저장</td>
      </tr>
      <tr>
        <td>보안</td>
        <td>클라리언트에 저장되므로 보안에 취약</td>
        <td>서버에 저장되므로 보안에 비교적 안전</td>
      </tr>
      <tr>
        <td>자원 / 속도</td>
        <td>서버 자원을 사용하지 않으므로 세션보다 빠르다.</td>
        <td>서버 자원을 사용하므로 쿠키보다 느림</td>
      </tr>
      <tr>
        <td>용량</td>
        <td>용량 제한 O</td>
        <td>서버가 허용하는 한 제한 X</td>
      </tr>
      <tr>
        <td>유지 시간</td>
        <td>쿠키 생성 시 설정. 설정된 시간이 경과되면 무조건 삭제됨</td>
        <td>
          서버의 web.xml에서 설정. 설정된 시간 내라도 동작이 있다면 삭제되지
          않고 유지
        </td>
      </tr>
    </table>

    <br />

    <h3>세션 핵심 요약</h3>
    <ul>
      <li>
        세션은 클라이언트가 웹 브라우저를 통해 서버에 접속한 후 웹 브라우저를
        닫을 때까지의 단위를 뜻함
      </li>
      <li>
        클라이언트가 서버에 접속한 동안 상태를 유지하기 위해 세션 영역을 이용해
        상태 정보를 저장
      </li>
      <li>세션의 유지 시간 설정은 web.xml을 이용하는 것이 편리함</li>
      <li>
        설정된 유지 시간 동안 아무런 동작이 없다면 세션은 소멸. 하지막 동작이
        있다면 계속 유지
      </li>
      <li>
        세션 영역은 다른 페이지와도 공유되므로 클라이언트별 상태 정보를
        관리하기에 아주 유용한 수단임.
      </li>
    </ul>

    <br />

    <h2>액션 태그</h2>
    <ul>
      <li>
        액션 태그의 특징
        <ul>
          <li>JSP의 표준 태그</li>
          <li>페이지 사이에서 이동 제어</li>
          <li>페이지 사이에서 자바 빈 생성 시 사용</li>
          <li>특별한 선언없이 &lt;jsp:태그명 /&gt; 으로 사용</li>
          <li>
            HTML 태그처럼 사용하지만 JSP 이므로 서버에서 처리된 결과(HTML)만
            출력
          </li>
          <li>XML 문법을 따름 -> 문법에 대해 HTML 보다 엄격함</li>
          <li>반드시 종료 태그를 닫아야 함.</li>
          <li>액션 태그 사이에 주석 사용 불가</li>
          <li>속성값 부여 시 &lt;%=%&gt;, 표현식 사용 불가</li>
        </ul>
      </li>
      <li>
        액션 태그의 종류
        <ul>
          <li>
            &lt;jsp:include 속성값 /&gt; : 외부 파일을 현재 파일에 포함 시킴 =>
            &lt;% include % &gt;
          </li>
          <li>
            &lt;jsp:forward /&gt; : 다른 페이지로 요청을 전달(페이지 이동)
          </li>
          <li>
            &lt;jsp:useBean /&gt;, &lt;jsp:getProperty /&gt;,
            &lt;jsp:setProperty /&gt; : 자바빈즈를 생성, 값 추출, 설정
          </li>
          <li>
            &lt;jsp:param /&gt; : 매개 변수 전달, &lt;jsp:include /&gt;,
            &lt;jsp:forward /&gt; 와 함께 사용
            <ul>
              <li>String 만 전달 가능</li>
              <li>
                객체 : 4가지 scope을 이용 page, request, session, application
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        include 지시어와 &lt;jsp:include /&gt;태그
        <ul>
          <li>현재 페이지에 다른 JSP 파일을 포함시킬 때 사용</li>
          <li>동작성에 차이가 있음</li>
          <li style="list-style: none">
            <table border="1">
              <tr>
                <th></th>
                <th>액션태그</th>
                <th>지시어</th>
              </tr>
              <tr>
                <td>형식</td>
                <td>&lt;jsp:include page='파일경로' /&gt;</td>
                <td>&lt;%@ include page='파일경로' %&gt;</td>
              </tr>
              <tr>
                <td>표현식</td>
                <td>
                  표현식 사용 가능 <br />
                  &lt;jsp:include page="&lt;%= 변수 %&gt;" /&gt;
                </td>
                <td>
                  사용 불가 <br />
                  &lt;%@ include file="&lt;%= 변수 %&gt;" %&gt; 사용할 수 없음
                </td>
              </tr>
              <tr>
                <td>포함 방식</td>
                <td>포함할 파일로 페이지 이동 -> 결과를 현재 페이지에 포함</td>
                <td>페이지 소스 자체를 현재 페이지에 포함시킨 후 처리</td>
              </tr>
              <tr>
                <td>변수</td>
                <td>
                  포함된(포함시킨) 파일에서 생성한 변수 포함시킨 파일에서 사용
                  불가
                </td>
                <td>포함된(포함시킨) 파일에서 생성한 변수 사용 가능</td>
              </tr>
              <tr>
                <td>page 영역</td>
                <td>공유되지 않음</td>
                <td>공유됨</td>
              </tr>
              <tr>
                <td>request 영역</td>
                <td>공유됨</td>
                <td>공유됨</td>
              </tr>
            </table>
          </li>
        </ul>
      </li>
      <li>
        자바빈의 사용
        <ul>
          <li>
            &lt;jsp:useBean&gt;, &lt;jsp:setProperty&gt;,
            &lt;jsp:getProperty&gt; 태그 사용
          </li>
          <li>자바빈즈를 생성 및 설정 시 사용</li>
          <li>
            자바빈즈는 프로퍼티(멤버변수), 메서드(멤버함수) getter/setter 로만
            구성
          </li>
          <li>
            자바빈즈의 생성
            <ul>
              <li>
                &lt;jsp:useBean id="자바빈즈 이름(저번에 사용했던 memberDTO가
                됨)" class="사용할 클래스명(dto.MemberDTO)"
                property="프로퍼티명" value="프로퍼티값" /&gt;
              </li>
            </ul>
          </li>
          <li>
            가지고 올 때
            <ul>
              <li>
                &lt;jsp:getProperty name="자바빈즈 이름" property="프로퍼티명
                /&gt;
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>

    <br />

    <h2>액션태그 정리</h2>
    <ul>
      <li>
        &lt;jsp:include&gt; 태그 : 특정 페이지를 현재 페이지에 포함시킬 때 사용
        <ul>
          <li>생성된 html 결과 리턴</li>
          <li>page 범위 공유 X, request 범위 공유</li>
        </ul>
      </li>
      <li>
        include 페이지 지시자와 유사, 동작성은 다르다.
        <ul>
          <li>jsp 내용이 포함시키는 페이지에 통째로 포함</li>
        </ul>
      </li>
      <li>&lt;jsp:forward&gt; 태그 : 요청을 전달하는 포워드에 사용</li>
      <li>
        &lt;jsp:useBean&gt;, &lt;jsp:setProperty&gt;, &lt;jsp:getProperty&gt;
        태그
        <ul>
          <li>자바빈즈 생성, 설정, 조회 시 사용</li>
          <li>
            *(와일드카드)는 설정 시 전송된 모든 파라미터를 객체의 프로퍼티에
            자동으로 맵핑 -> 전송 태그의 이름 == 객체의 프로퍼티명
          </li>
        </ul>
      </li>
      <li>
        &lt;jsp:param&gt; 태그 : 인클루드, 포워드 시 매개변수를 넘길 때 사용
      </li>
    </ul>

    <br />

    <h2>모델 1 구조</h2>
    <p>
      모델 1 구조는 JSP만으로 구성된 웹 애플리케이션 구조입니다. 사용자의 요청을
      JSP가 직접 처리하며, 데이터 조회와 화면 표시를 모두 JSP에서 담당합니다.
      단순한 구조로 소규모 프로젝트에 적합하지만, 유지보수가 어렵습니다.
    </p>

    <br />

    <h2>모델 2 구조 (MVC)</h2>
    <p>
      모델 2 구조는 MVC(Model-View-Controller) 패턴을 따르는 구조입니다.
      Controller(서블릿)가 요청을 처리하고, Model은 데이터와 비즈니스 로직을
      담당하며, View(JSP)는 화면 표시만을 담당합니다. 역할이 분리되어 있어
      유지보수와 확장성이 뛰어나며, 대규모 프로젝트에 적합합니다.
    </p>

    <br />

    <h3>모델 1과 모델 2의 차이점</h3>
    <table border="1">
      <tr>
        <th>구분</th>
        <th>모델 1 구조</th>
        <th>모델 2 구조 (MVC)</th>
      </tr>
      <tr>
        <td>구성 요소</td>
        <td>JSP만 사용</td>
        <td>JSP, 서블릿, Java 클래스</td>
      </tr>
      <tr>
        <td>처리 방식</td>
        <td>JSP가 직접 요청을 받아 처리</td>
        <td>서블릿이 요청을 처리하고, JSP로 결과 전달</td>
      </tr>
      <tr>
        <td>적합한 프로젝트 규모</td>
        <td>소규모 프로젝트</td>
        <td>대규모 프로젝트</td>
      </tr>
      <tr>
        <td>유지보수성</td>
        <td>낮음 (로직과 UI 혼재)</td>
        <td>높음 (로직과 UI 분리)</td>
      </tr>
      <tr>
        <td>확장성</td>
        <td>제한적</td>
        <td>우수함</td>
      </tr>
      <tr>
        <td>초기 개발 난이도</td>
        <td>쉬움</td>
        <td>어려움</td>
      </tr>
    </table>

    <br />

    <h2>표현 언어 (EL)</h2>
    <ul>
      <li>표현언어 (EL : Expression Language)</li>
      <li>변수의 값을 출력할 때 사용하는 스크립트 언어</li>
      <li>사용법이 간결하고, 형 변환에 관대함 (오류 감소)</li>
      <li>산술, 비교, 논리 연산 가능</li>
      <li>JSP 내장 객체 영역에 담긴 속성 그대로 사용</li>
      <li>자바 클래스에 정의된 메서드 호출 가능</li>
      <li>EL은 HTML, CSS, Javascript 어디서든 사용 가능</li>
    </ul>

    <br />

    <h3>표현식과 EL의 차이점</h3>
    <ul>
      <li>
        표현식 <code>&lt;%= %&gt;</code>과 다르게 EL은 4가지 영역에 저장된 값을
        출력 가능
      </li>
      <li>스크립틀릿에서 저장한 변수는 사용 불가</li>
    </ul>

    <br />

    <h3>EL 기본 사용법</h3>
    <ul>
      <li>기본 문법: <code>${ 속성(변수) }</code></li>
      <li>
        예: <code>${ pageScope 변수 }</code>,
        <code>${ requestScope 변수 }</code>
      </li>
      <li>특수문자가 있는 속성은 <code>["속성명"]</code> 형태로 사용</li>
    </ul>

    <br />

    <h3>객체 표현 방식</h3>
    <table border="1">
      <tr>
        <th>형태</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>객체.하위요소</td>
        <td>일반적인 객체 접근 방식</td>
      </tr>
      <tr>
        <td>객체["하위요소"]</td>
        <td>특수문자가 포함된 속성명 사용 시</td>
      </tr>
      <tr>
        <td>객체['하위요소']</td>
        <td>객체의 속성명을 작은 따옴표로 사용할 때</td>
      </tr>
      <tr>
        <td>header["user-agent"]</td>
        <td>HTTP 헤더 정보를 EL로 가져올 때</td>
      </tr>
    </table>

    <br />

    <h3>4가지 영역 접근 방법</h3>
    <table>
      <tr>
        <th>영역</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>pageScope</td>
        <td>현재 페이지 내에서 사용</td>
      </tr>
      <tr>
        <td>requestScope</td>
        <td>하나의 요청 내에서 사용</td>
      </tr>
      <tr>
        <td>sessionScope</td>
        <td>세션 내에서 사용 (사용자별 데이터 유지)</td>
      </tr>
      <tr>
        <td>applicationScope</td>
        <td>서버의 애플리케이션 전체에서 사용</td>
      </tr>
    </table>

    <br />

    <h3>속성 관리 메서드</h3>
    <ul>
      <li><strong>setAttribute</strong>: 속성 저장</li>
      <li><strong>getAttribute</strong>: 속성 가져오기</li>
      <li><strong>removeAttribute</strong>: 속성 삭제</li>
    </ul>

    <br />

    <h3>폼 값 전송</h3>
    <ul>
      <li><strong>param</strong> : request.getParameter() 와 동일 - 단일</li>
      <li>
        <strong>paramValues</strong> : request.getParameterValues() 와 동일 -
        문자열 배열로 처리
      </li>
      <li>객체도 전달하여 처리 가능</li>
    </ul>

    <br />

    <h3>EL 내장 객체</h3>
    <ul>
      <li><strong>cookie</strong>: 쿠키를 읽을 때 사용</li>
      <li>
        <strong>header</strong>: request.getHeader()와 동일, 헤더값을 읽을 때
        사용
      </li>
      <li>
        <strong>headerValues</strong>: request.getHeaders()와 동일, 헤더값을
        배열 형태로 접근
      </li>
      <li>
        <strong>initParam</strong>: web.xml에 설정한 context 변수 읽을 때 사용
      </li>
      <li>
        <strong>pageContext</strong>: JSP의 pageContext 내장 객체와 같은 역할
      </li>
    </ul>

    <br />

    <h3>EL 연산자</h3>
    <table border="1">
      <tr>
        <th>종류</th>
        <th>연산자</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>산술 연산자</td>
        <td>+, -, *, /(div), %(mod)</td>
        <td>덧셈, 뺄셈, 곱셈, 나눗셈, 나머지 계산</td>
      </tr>
      <tr>
        <td rowspan="2">비교 연산자</td>
        <td>==, eq</td>
        <td>같음 비교</td>
      </tr>
      <tr>
        <td>!=, ne</td>
        <td>다름 비교</td>
      </tr>
      <tr>
        <td rowspan="4"></td>
        <td>&lt;, lt</td>
        <td>작음 비교</td>
      </tr>
      <tr>
        <td>&lt;=, le</td>
        <td>작거나 같음 비교</td>
      </tr>
      <tr>
        <td>&gt;, gt</td>
        <td>큼 비교</td>
      </tr>
      <tr>
        <td>&gt;=, ge</td>
        <td>크거나 같음 비교</td>
      </tr>
      <tr>
        <td>논리 연산자</td>
        <td>&& (and), || (or), ! (not)</td>
        <td>그리고, 또는, 부정 논리 연산</td>
      </tr>
      <tr>
        <td>empty 연산자</td>
        <td>empty</td>
        <td>값이 비어있는지 (null, 빈 문자열, 빈 컬렉션 등) 검사</td>
      </tr>
      <tr>
        <td>조건부 연산자</td>
        <td>조건 ? True : False</td>
        <td>삼항 연산자로 조건에 따라 값을 선택 (조건 ? 참 : 거짓)</td>
      </tr>
    </table>

    <br />

    <h3>정리</h3>
    <ul>
      <li>EL은 내장객체를 통하여 데이터를 출력하는 용도</li>
      <li>내장 객체를 통해 4가지 영역에 저장된 속성값을 읽을 수 있다.</li>
      <li>전송된 폼 값, 객체를 EL을 통하여 조회 가능</li>
      <li>컬렉션을 더 쉽게 사용할 수 있음</li>
      <li>자바에서 제공하는 연산자 사용 가능</li>
      <li>
        JSP 코드를 직접 사용은 불가하나, 메서드를 호출할 수 있는 기능 제공
      </li>
      <li>EL에서는 null도 0으로 인식되어 예외가 발생하지 않는다.</li>
    </ul>

    <h2>JSTL(JSP Standard Tag Library) - JSP 표준 태그 라이브러리</h2>
    <ul>
      <li>모델2 방식으로 개발할 때, EL과 함께 사용됨</li>
      <li>4가지 영역에 저장된 값을 사용할 수 있음</li>
      <li>코어 태그, 국제화 태그, XML 태그가 주로 사용됨</li>
    </ul>

    <ul>
      <li>
        JSTL
        <ul>
          <li>
            JSP 에서 자주 사용되는 제어문, 반복문 등을 모아둔 표준 라이브러리
          </li>
          <li>JSTL을 사용하면 스크립틀릿 없이 태그만으로 작업 가능</li>
          <li>
            JSTL 사용 설정
            <ul>
              <li>
                <a href="https://mvnrepository.com/"
                  >Jakarta.servlet.jsp.jstl-api-3.0.1.jar 다운 후 lib 폴더에
                  추가</a
                >
              </li>
            </ul>
          </li>
        </ul>
      </li>
      <li>
        사용 가능한 태그 종류
        <table border="1">
          <tr>
            <th>태그</th>
            <th>기능</th>
            <th>접두어</th>
            <th>URI</th>
          </tr>
          <tr>
            <td>Core태그</td>
            <td>변수 선언, 조건문/반복문, URL 처리 등등</td>
            <td>c</td>
            <td>jakarta.tags.core</td>
          </tr>
          <tr>
            <td>Formatting태그</td>
            <td>숫자, 날짜, 시간 포맷 지정</td>
            <td>frm</td>
            <td>jakarta.tags.fmt</td>
          </tr>
          <tr>
            <td>XML태그</td>
            <td>XML 파싱</td>
            <td>x</td>
            <td>jakarta.tags.xml</td>
          </tr>
          <tr>
            <td>Function태그</td>
            <td>컬렉션, 문자열 처리</td>
            <td>fn</td>
            <td>jakarta.tags.functions</td>
          </tr>
          <tr>
            <td>SQL태그</td>
            <td>데이터베이스 연결 및 쿼리 실행</td>
            <td>sql</td>
            <td>jakarta.tags.sql</td>
          </tr>
        </table>
      </li>
    </ul>

    <br />

    <h2>JSTL 코어 태그 종류</h2>
    <table border="1">
      <tr>
        <th>태그</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>&lt;c:set&gt;</td>
        <td>변수를 설정하거나 값을 저장할 때 사용</td>
      </tr>
      <tr>
        <td>&lt;c:out&gt;</td>
        <td>
          특정 값을 출력할 때 사용하며, HTML 태그와 특수 문자를 이스케이프 처리
        </td>
      </tr>
      <tr>
        <td>&lt;c:remove&gt;</td>
        <td>지정한 변수를 제거할 때 사용</td>
      </tr>
      <tr>
        <td>&lt;c:catch&gt;</td>
        <td>예외 처리를 위한 블록을 정의할 때 사용</td>
      </tr>
      <tr>
        <td>&lt;c:if&gt;</td>
        <td>조건을 만족할 때 특정 코드를 실행</td>
      </tr>
      <tr>
        <td>&lt;c:choose&gt;</td>
        <td>다중 조건문을 사용할 때 사용 (switch문과 유사)</td>
      </tr>
      <tr>
        <td>&lt;c:when&gt;</td>
        <td>&lt;c:choose&gt; 내에서 특정 조건이 참일 때 실행</td>
      </tr>
      <tr>
        <td>&lt;c:otherwise&gt;</td>
        <td>&lt;c:choose&gt; 내에서 조건이 모두 거짓일 때 실행</td>
      </tr>
      <tr>
        <td>&lt;c:forEach&gt;</td>
        <td>컬렉션이나 배열을 반복 처리할 때 사용</td>
      </tr>
      <tr>
        <td>&lt;c:forTokens&gt;</td>
        <td>특정 구분자를 기준으로 문자열을 나누어 반복 처리</td>
      </tr>
      <tr>
        <td>&lt;c:import&gt;</td>
        <td>외부 URL이나 다른 페이지의 내용을 포함할 때 사용</td>
      </tr>
      <tr>
        <td>&lt;c:url&gt;</td>
        <td>URL을 재작성하거나 파라미터를 추가할 때 사용</td>
      </tr>
      <tr>
        <td>&lt;c:redirect&gt;</td>
        <td>다른 페이지로 리다이렉트할 때 사용</td>
      </tr>
      <tr>
        <td>&lt;c:param&gt;</td>
        <td>&lt;c:url&gt; 태그와 함께 사용하여 파라미터를 추가</td>
      </tr>
    </table>

    <br />

    <h3>&lt;c:out&gt; 태그</h3>
    <table border="1">
      <tr>
        <th>속성</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>value</td>
        <td>출력할 값 (필수)</td>
      </tr>
      <tr>
        <td>default</td>
        <td>value가 null일 때 출력할 기본값</td>
      </tr>
      <tr>
        <td>escapeXml</td>
        <td>HTML 태그와 특수 문자의 이스케이프 처리 여부 (기본값: true)</td>
      </tr>
    </table>

    <h3>&lt;c:set&gt; 태그</h3>
    <table border="1">
      <tr>
        <th>속성</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>var</td>
        <td>저장할 변수 이름 (필수)</td>
      </tr>
      <tr>
        <td>value</td>
        <td>저장할 값</td>
      </tr>
      <tr>
        <td>scope</td>
        <td>변수가 저장될 범위 (page, request, session, application)</td>
      </tr>
    </table>

    <h3>&lt;c:remove&gt; 태그</h3>
    <table border="1">
      <tr>
        <th>속성</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>var</td>
        <td>제거할 변수 이름 (필수)</td>
      </tr>
      <tr>
        <td>scope</td>
        <td>변수가 제거될 범위 (page, request, session, application)</td>
      </tr>
    </table>

    <h3>&lt;c:if&gt; 태그</h3>
    <table border="1">
      <tr>
        <th>속성</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>test</td>
        <td>조건을 표현하는 논리식 (필수)</td>
      </tr>
    </table>

    <h3>&lt;c:choose&gt;, &lt;c:when&gt;, &lt;c:otherwise&gt; 태그</h3>
    <table border="1">
      <tr>
        <th>태그</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>&lt;c:when&gt;</td>
        <td>조건을 표현하는 논리식을 갖는 태그</td>
      </tr>
      <tr>
        <td>&lt;c:otherwise&gt;</td>
        <td>모든 조건이 거짓일 때 실행되는 태그</td>
      </tr>
    </table>

    <h3>&lt;c:forEach&gt; 태그</h3>
    <table border="1">
      <tr>
        <th>속성</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>var</td>
        <td>반복 시 사용할 변수 이름</td>
      </tr>
      <tr>
        <td>items</td>
        <td>반복할 컬렉션 또는 배열 (필수)</td>
      </tr>
      <tr>
        <td>begin</td>
        <td>반복 시작 인덱스</td>
      </tr>
      <tr>
        <td>end</td>
        <td>반복 종료 인덱스</td>
      </tr>
      <tr>
        <td>step</td>
        <td>반복 시 증가하는 값</td>
      </tr>
    </table>

    <h3>&lt;c:forTokens&gt; 태그</h3>
    <table border="1">
      <tr>
        <th>속성</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>var</td>
        <td>반복 시 사용할 변수 이름 (필수)</td>
      </tr>
      <tr>
        <td>items</td>
        <td>토큰으로 나눌 문자열 (필수)</td>
      </tr>
      <tr>
        <td>delims</td>
        <td>문자열을 나눌 구분자 (필수)</td>
      </tr>
    </table>

    <h3>&lt;c:import&gt; 태그</h3>
    <table border="1">
      <tr>
        <th>속성</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>url</td>
        <td>가져올 외부 페이지의 URL (필수)</td>
      </tr>
      <tr>
        <td>var</td>
        <td>결과를 저장할 변수 이름</td>
      </tr>
      <tr>
        <td>scope</td>
        <td>결과가 저장될 범위</td>
      </tr>
    </table>

    <h3>&lt;c:url&gt; 태그</h3>
    <table border="1">
      <tr>
        <th>속성</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>value</td>
        <td>URL 경로 (필수)</td>
      </tr>
      <tr>
        <td>var</td>
        <td>결과를 저장할 변수 이름</td>
      </tr>
    </table>

    <h3>&lt;c:redirect&gt; 태그</h3>
    <table border="1">
      <tr>
        <th>속성</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>url</td>
        <td>리다이렉트할 URL (필수)</td>
      </tr>
    </table>

    <h3>&lt;c:param&gt; 태그</h3>
    <table border="1">
      <tr>
        <th>속성</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>name</td>
        <td>추가할 파라미터 이름 (필수)</td>
      </tr>
      <tr>
        <td>value</td>
        <td>추가할 파라미터 값 (필수)</td>
      </tr>
    </table>

    <br />

    <h3>JSTL Formatting 태그 종류</h3>
    <table border="1">
      <tr>
        <th>태그</th>
        <th>속성</th>
        <th>설명</th>
      </tr>
      <tr>
        <td>&lt;fmt:formatNumber&gt;</td>
        <td>value, type, pattern</td>
        <td>숫자를 형식화하여 출력 (예: 소수점, 통화 형식 등)</td>
      </tr>
      <tr>
        <td>&lt;fmt:parseNumber&gt;</td>
        <td>value, type, pattern</td>
        <td>문자열을 숫자로 변환</td>
      </tr>
      <tr>
        <td>&lt;fmt:formatDate&gt;</td>
        <td>value, pattern, type</td>
        <td>날짜를 지정한 형식으로 변환하여 출력</td>
      </tr>
      <tr>
        <td>&lt;fmt:parseDate&gt;</td>
        <td>value, pattern</td>
        <td>문자열을 날짜 객체로 변환</td>
      </tr>
      <tr>
        <td>&lt;fmt:bundle&gt;</td>
        <td>basename</td>
        <td>리소스 번들을 지정하여 다국어 메시지 사용</td>
      </tr>
      <tr>
        <td>&lt;fmt:message&gt;</td>
        <td>key</td>
        <td>리소스 번들에서 특정 키에 해당하는 메시지를 출력</td>
      </tr>
      <tr>
        <td>&lt;fmt:setLocale&gt;</td>
        <td>value</td>
        <td>페이지의 로케일 정보를 설정</td>
      </tr>
      <tr>
        <td>&lt;fmt:timeZone&gt;</td>
        <td>value</td>
        <td>시간대를 설정하여 날짜 및 시간 형식 변환 시 사용</td>
      </tr>
    </table>

    <br />

    <h2>XML 태그</h2>
    <p>XML 파싱 및 출력, 흐름 제어 등의 기능 제공</p>
    <ul>
      <li>
        Xalan.jar 라이브러리 필요
        <ul>
          <li>
            <a href="https://mvnrepository.com/"
              >xalan-2.7.2.jar 다운 후 lib 폴더에 추가</a
            >
          </li>
        </ul>
      </li>
    </ul>

    <br />

    <h3>JSTL 요약</h3>
    <ul>
      <li>
        <strong>Core 태그</strong> : 프로그래밍 언어에서 가장 기본이 되는 변수
        선언, 조건문, 반복문 등을 대체하는 태그를 제공
      </li>
      <li>
        <strong>Formatting 태그</strong> : 국가별로 다양한 언어, 날짜와 시간,
        숫자 형식을 설정할 때 사용
      </li>
      <li>
        <strong>XML 태그</strong> : XML 문서를 처리하기 위한 태그들로 XML 파싱,
        출력, 흐름 제어 등의 기능을 제공
      </li>
    </ul>

    <br />

    <h2>서블릿</h2>

    <h3 style="border: none">서블릿이란?</h3>
    JSP 나오기 전에 자바로 웹 어플리케이션을 개발했던 방법<br />
    서버 단에서 클라이언트의 요청을 받아 처리한 후 응답하는 역할을 해줌.

    <br />

    <h3>서블릿의 특징</h3>
    <ul>
      <li>
        클라이언트의 요청에 대해 동적으로 작동하는 웹 애플리케이션 컴포넌트
      </li>
      <p>
        서블릿은 웹 브라우저 같은 클라이언트가 서버에 어떤 요청을 보낼 때 그
        요청에 맞춰 동작한다. 예를 들어, 사용자가 웹사이트에서 버튼을 클릭하면
        그 클릭에 따라 필요한 정보를 제공하거나 처리할 수 있는 역할을 한다.
      </p>
      <li>MVC 모델에서 컨트롤러 역할을 함.</li>
      <p>
        MVC(Model-View-Controller) 모델에서 서블릿은 컨트롤러 역할을 한다.
        컨트롤러는 사용자의 요청을 받아 적절한 데이터를 준비하고, 해당 데이터를
        보여줄 뷰(view)에 전달한다. 쉽게 말해, 서블릿은 사용자와 서버 간의
        중간에서 데이터 흐름을 조정하는 역할을 한다.
      </p>
      <li>모든 메서드는 스레드로 동작됨.</li>
      <p>
        서블릿은 여러 사용자가 동시에 요청하더라도 각 요청을 별도의 스레드로
        처리하여 효율성을 높인다. 스레드는 동시에 여러 작업을 할 수 있게 해 주는
        기능이라서, 여러 사용자가 한 번에 웹페이지를 요청해도 문제가 생기지
        않도록 돕는다.
      </p>
      <li>jakarta.servlet.http 패키지의 HttpServlet 클래스를 상속받음</li>
      <p>
        서블릿은 HttpServlet이라는 기본 클래스를 상속받아 만들어진다. 이
        클래스를 상속받음으로써 웹 요청을 처리할 때 필요한 다양한 기능을 쉽게
        사용할 수 있다. HttpServlet은 웹 개발에 필요한 기본적인 도구들을 제공해
        주는 클래스다.
      </p>
    </ul>

    <br />

    <h3>서블릿 컨테이너의 역할</h3>
    <p>
      서블릿 컨테이너 : 서블릿을 관리하는 컨테이너<br />
      서블릿의 수명주기를 관리하고 요청이 오면 스레드를 생성해 처리<br />
      또한 클라이언트의 요청을 받아서 응답을 보낼 수 있도록 통신을 지원해줌.
    </p>
    <ul>
      <li>
        <strong>통신 지원</strong> : 클라이언트와 통신하려면 서버는 특정 포트로
        소켓을 열고 I/O 스트림을 생성하는 등 복잡한 과정이 필요.<br />
        서블릿 컨테이너는 이 과정을 간단히 해주는 API를 제공한다.
      </li>
      <li>
        <strong>수명주기 관리</strong> : 서블릿을 인스턴스화한 후 초기화하고
        요청에 맞는 적절한 메서드를 호출한다.<br />
        응답 후에는 가비지 컬렉션을 통해 객체를 소멸시킨다.
      </li>
      <li>
        <strong>멀티스레딩 관리</strong> : 서블릿 요청들은 스레드를 생성해
        처리.<br />
        즉, 멀티스레드 방식으로 여러 요청을 동시에 처리할 수 있다.
      </li>
      <li>
        <strong>선언적인 보안 관리 및 JSP 지원</strong> : 서블릿 컨테이너는 보안
        기능을 지원하므로 별도로 구현하지 않아도 된다.
      </li>
    </ul>

    <br />

    <h3>서블릿의 동작 방식</h3>
    <ol>
      <li>클라이언트의 요청(Request)</li>
      <p>
        사용자가 웹 브라우저를 통해 특정 URL을 요청하면, 이 요청은 HTTP
        프로토콜을 통해 서버로 전달된다. 예를 들어, 사용자가 검색 버튼을 누르면
        해당 검색어와 함께 요청이 서버로 전송된다.
      </p>

      <li>요청을 서블릿 컨테이너(Servlet Container)가 받음</li>
      <p>
        서버에 있는 서블릿 컨테이너(예: Tomcat)는 클라이언트의 요청을 받는다.
        서블릿 컨테이너는 요청을 처리할 서블릿을 찾고, 해당 서블릿을 호출해
        요청을 처리할 준비를 한다. 서블릿 컨테이너는 서블릿의 생명주기 관리도
        담당한다.
      </p>

      <li>HttpServlet 객체의 생성과 초기화</li>
      <p>
        서블릿 컨테이너는 해당 서블릿이 처음 호출되었을 때, 서블릿 객체를
        생성하고, 초기화 메서드인 <code>init()</code>을 호출한다. 이 단계는
        서블릿이 초기 설정을 수행할 수 있도록 한다. 이 과정은 서블릿이 처음
        로드될 때 한 번만 수행된다.
      </p>

      <li>요청을 처리하는 <code>service()</code> 메서드 호출</li>
      <p>
        클라이언트로부터 요청이 올 때마다 서블릿 컨테이너는 서블릿의
        <code>service()</code> 메서드를 호출한다. 이 메서드는 클라이언트의 요청
        타입(GET, POST 등)에 따라 적절한 <code>doGet()</code> 또는
        <code>doPost()</code> 메서드를 호출하여 요청을 처리한다.
      </p>

      <li>클라이언트 요청에 따른 처리</li>
      <p>
        서블릿은 <code>doGet()</code>, <code>doPost()</code>와 같은 메서드에서
        클라이언트의 요청을 처리하고, 필요한 데이터를 가공하거나 데이터베이스와
        상호작용하여 결과를 생성한다. 예를 들어, 사용자가 검색어를 입력하면,
        데이터베이스에서 해당 검색어에 맞는 데이터를 조회해 결과를 만든다.
      </p>

      <li>응답(Response) 생성 및 전송</li>
      <p>
        서블릿은 요청을 처리한 후, <code>HttpServletResponse</code> 객체를
        사용해 클라이언트에게 응답을 보낸다. 응답은 HTML, JSON, XML 등 다양한
        형식으로 생성될 수 있으며, 클라이언트는 이 응답을 받아 웹 브라우저에
        표시한다.
      </p>

      <li>서블릿의 소멸</li>
      <p>
        서블릿 컨테이너는 서버가 종료되거나 서블릿이 더 이상 필요하지 않을 때
        <code>destroy()</code> 메서드를 호출해 서블릿 객체를 소멸시킨다. 이
        단계에서 서블릿은 리소스를 해제하는 등의 정리 작업을 수행한다.
      </p>
    </ol>

    <br />

    <h3>서블릿 작성 규칙</h3>
    <ol>
      <li>
        기본적으로 jakarta.servlet, jakarta.servlet.http.java.io 패키지를 임포트
        한다.
      </li>
      <li>
        서블릿 클래스는 반드시 public으로 선언, HttpServlet을 상속받아야 함.
      </li>
      <li>
        클라이언트의 요청을 처리하기 위해 doGet()이나 doPost()를 반드시
        오버라이딩 해야함.
      </li>
      <li>
        doGet(), doPost() 메서드로 ServletException과 IOException 예외를
        던지도록 선언
      </li>
      <li>
        doGet() 또는 doPost() 메서드를 호출할 때의 매개변수는
        HttpServletRequest와 HttpServletResponse를 사용함.
      </li>
    </ol>

    <br />

    <h3>서블릿 작성</h3>
    <p>
      서블릿 작성은 클라이언트의 요청을 전달할 '요청명'을 결정하는 일부터
      시작한다. JSP에서는 클라이언트의 요청을 JSP가 직접 받아 처리하지만,
      서블릿은 요청명을 기준으로 이를 처리할 서블릿을 선택하게 된다. 요청명과
      서블릿을 연결해주는 작업을 매핑(mapping)이라고 한다.
    </p>
    <h4>매핑의 두가지 방식</h4>
    <ol>
      <li>web.xml에서 매핑</li>
      <li>@WebServlet 어노테이션을 사용하여 코드에 직접 명시하는 방법</li>
    </ol>

    <br />

    <h3>web.xml에서 매핑</h3>
    <textarea class="javaCode" readonly>
// web.xml

// 서블릿 등록
<servlet>
  <servlet-name>서블릿명</servlet-name>
  <servlet-class>패키지를 포함한 서블릿 클래스명</servlet-class>
</servlet>

// 서블릿과 요청명(요청 URL) 매핑
<servlet-mapping>
  <servlet-name>서블릿명</servlet-name> // 위와 동일한 이름 입력
  <url-pattern>클라이언트 요청 URL</url-pattern> // '/' <- 로 시작하는 경로를 사용해야 함
</servlet-mapping>

ex) http:// : 프로토콜
    localhost:8080 : 호스트명
    /Mobp : 컨텍스트루트명
    /Post/Study/JspStudy/jsp10.jsp : 요청명
    </textarea>

    <br />

    <h3>@WebServlet 어노테이션으로 매핑</h3>
    <textarea class="javaCode" readonly>
// ServletTest.java

package jsp;

@WebServlet("/jspStudyServlet.do")
public class ServletTest extends HttpServlet {
  // serialVersionUID : 직렬화 된 클래스의 버전 관리에 사용되는 식별자 명시적으로 선언함.
  private static final long serialVersionUID = 1L;
  @Override
  protected void doGet(HttpServletRequest req, HttpServletResponse res)
    throws ServletException, IOException {
      // 실행부;
    }
}
    </textarea>

    <br />

    <h2>서블릿의 수명주기 메서드</h2>

    <br />

    <h3 style="border: none">1. init() 메서드</h3>
    <ul>
      <li>
        <strong>설명</strong>: 서블릿이 처음 생성될 때 한 번만 호출되는
        메서드입니다.
      </li>
      <li>
        <strong>용도</strong>: 서블릿 초기화 작업을 수행하며, 서블릿이 요청을
        처리할 준비를 마치기 위해 필요한 설정을 여기서 처리할 수 있습니다.
      </li>
      <li>
        <strong>호출 시점</strong>: 서블릿이 처음 요청을 받으면 컨테이너는
        서블릿 인스턴스를 생성하고 init() 메서드를 호출합니다.
      </li>
      <li><strong>예시</strong>:</li>
      <textarea class="javaCode" readonly>
@Override
public void init() throws ServletException {
    // 초기화 작업 수행
    System.out.println("서블릿 초기화 중...");
}
        </textarea
      >
    </ul>

    <br />

    <h3 style="border: none">2. service() 메서드</h3>
    <ul>
      <li>
        <strong>설명</strong>: 클라이언트의 요청을 처리하고 응답을 생성하는
        메서드입니다.
      </li>
      <li>
        <strong>용도</strong>: HTTP 요청을 받아 처리하며, 서블릿이 동작하는 동안
        여러 번 호출될 수 있습니다. doGet()과 doPost()와 같은 메서드가 내부에서
        호출됩니다.
      </li>
      <li>
        <strong>호출 시점</strong>: 클라이언트가 서블릿에 요청을 보낼 때마다
        호출됩니다.
      </li>
      <li><strong>예시</strong>:</li>
      <textarea class="javaCode" readonly>
@Override
protected void service(HttpServletRequest req, HttpServletResponse resp) 
        throws ServletException, IOException {
    // 요청에 따라 doGet(), doPost() 등 처리
    System.out.println("요청 처리 중...");
    super.service(req, resp);
}
        </textarea
      >
    </ul>

    <br />

    <h3 style="border: none">3. destroy() 메서드</h3>
    <ul>
      <li>
        <strong>설명</strong>: 서블릿이 메모리에서 언로드될 때(삭제될 때)
        호출되는 메서드입니다.
      </li>
      <li>
        <strong>용도</strong>: 서블릿 종료 전에 리소스를 정리하거나 필요한 종료
        작업을 수행할 때 사용됩니다.
      </li>
      <li>
        <strong>호출 시점</strong>: 서버가 종료되거나 서블릿이 더 이상 사용되지
        않아 메모리에서 제거될 때 호출됩니다.
      </li>
      <li><strong>예시</strong>:</li>
      <textarea class="javaCode" readonly>
@Override
public void destroy() {
    // 종료 작업 수행
    System.out.println("서블릿 종료 중...");
}
        </textarea
      >
    </ul>

    <br />

    <h3 style="border: none">@PostConstruct 어노테이션</h3>
    <ul>
      <li>
        <strong>설명</strong>: 서블릿이나 다른 Java 객체가 초기화될 때 호출되는
        메서드에 붙이는 어노테이션입니다.
      </li>
      <li>
        <strong>용도</strong>: 객체 생성 후 바로 실행해야 하는 초기화 작업을
        수행할 때 사용됩니다. 주로 서블릿의 의존성 주입이 완료된 후 호출됩니다.
      </li>
      <li>
        <strong>호출 시점</strong>: 서블릿이나 자바 객체가 생성된 후, `init()`
        메서드가 호출되기 전에 실행됩니다.
      </li>
      <li><strong>예시</strong>:</li>
      <textarea class="javaCode" readonly>
import javax.annotation.PostConstruct;

@PostConstruct
public void postConstruct() {
    // 초기화 작업 수행
    System.out.println("@PostConstruct 메서드 호출됨");
}
        </textarea
      >
    </ul>

    <br />

    <h3 style="border: none">@PreDestroy 어노테이션</h3>
    <ul>
      <li>
        <strong>설명</strong>: 서블릿이나 다른 Java 객체가 종료될 때 호출되는
        메서드에 붙이는 어노테이션입니다.
      </li>
      <li>
        <strong>용도</strong>: 객체가 파괴되기 전에 반드시 수행해야 하는
        작업(예: 리소스 해제)을 정의할 때 사용됩니다.
      </li>
      <li>
        <strong>호출 시점</strong>: `destroy()` 메서드가 호출되기 직전에
        실행됩니다.
      </li>
      <li><strong>예시</strong>:</li>
      <textarea class="javaCode" readonly>
import javax.annotation.PreDestroy;

@PreDestroy
public void preDestroy() {
    // 종료 작업 수행
    System.out.println("@PreDestroy 메서드 호출됨");
}
        </textarea
      >
    </ul>

    <br />

    <h3>서블릿 수명 주기 요약</h3>
    <ol>
      <li>
        <strong>서블릿 객체 생성</strong>: 최초의 요청이 들어올 때 서블릿 객체가
        생성됩니다.
      </li>
      <li><strong>init() 호출</strong>: 서블릿의 초기화 작업을 수행합니다.</li>
      <li>
        <strong>@PostConstruct 호출</strong>: 서블릿 초기화 후, 추가적으로
        수행할 초기화 작업을 정의합니다.
      </li>
      <li>
        <strong>service() 호출</strong>: 클라이언트의 요청이 들어올 때마다
        service() 메서드가 호출되며, 내부적으로 doGet(), doPost() 등으로
        분기합니다.
      </li>
      <li>
        <strong>@PreDestroy 호출</strong>: 서블릿 종료 전에 수행해야 할 정리
        작업을 정의합니다.
      </li>
      <li>
        <strong>destroy() 호출</strong>: 서블릿이 더 이상 사용되지 않을 때
        메모리에서 제거되며 destroy() 메서드가 호출됩니다.
      </li>
    </ol>

    <br />

    <h3>서블릿 요약</h3>
    <ul>
      <li>
        MVC 패턴은 서비스를 모델, 뷰, 컨트롤러로 나눠 개발하는 방법, 서블릿은
        컨트롤러 역할을 함.
      </li>
      <li>
        서블릿을 사용하면 MVC 패턴을 적용한 모델2 방식으로 웹 애플리케이션을
        개발할 수 있다.
      </li>
      <li>
        요청명(요청URL)과 이를 처리할 파일(서블릿)이 분리되어 있어서 둘을
        매핑해줘야 함.
      </li>
      <li>
        요청명과의 매핑은 web.xml을 이용하는 방식과 @WebServlet 어노테이션을
        이용하는 방식 제공.
      </li>
      <li>
        서블릿은 HttpServlet 클래스를 상속받은 후 요청을 처리할 doGet() 혹은
        doPost() 메서드를 오버라이딩하여 제작.
      </li>
      <li>
        와일드카드(*)를 사용하여 여러 가지 요청을 하나의 서블릿에서 처리하도록
        매핑할 수 있다.
      </li>
      <li>
        수명주기 메서드에서 확인했듯 두 번째 요청부터는 첫 번째 요청 때 만들어둔
        객체를 재사용하므로 처리 속도가 빨라짐.
      </li>
    </ul>

    <br />

    <p>파일 부분은 일단 다음에</p>

    <script src="script.js"></script>
  </body>
</html>
